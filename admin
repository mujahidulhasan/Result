<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>PDF → BTEB Result JSON Extractor (full)</title>
  <script src="https://unpkg.com/pdfjs-dist@3.5.141/build/pdf.min.js"></script>
  <style>
    body{font-family:Inter,system-ui,Arial;margin:0;background:#071428;color:#e6f0fb;padding:18px}
    .wrap{max-width:1100px;margin:16px auto}
    h1{font-size:20px;color:#9fd1ff}
    input[type=file]{display:block;margin-top:10px;padding:10px;border-radius:8px;background:#0b2940;border:1px solid rgba(255,255,255,0.04);color:#e6f0fb}
    button{margin-top:10px;padding:10px 14px;border-radius:8px;border:none;background:#0b8fff;color:white;cursor:pointer}
    textarea{width:100%;height:420px;margin-top:14px;padding:12px;border-radius:8px;background:#021426;color:#dbeeff;border:1px solid rgba(255,255,255,0.04);font-family:monospace;white-space:pre-wrap;overflow:auto}
    .small{font-size:13px;color:#9fb6d6;margin-top:8px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:8px}
    .note{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;margin-top:12px;color:#bcd9ff}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>PDF → BTEB Result JSON Extractor</h1>
    <div class="note">
      Upload the board PDF (e.g. <code>RESULT_4th_2022_Regulation.pdf</code>). The tool will try to extract:
      <ul>
        <li>polytechnic (institute) name</li>
        <li>exam name (e.g. DIPLOMA IN ENGINEERING)</li>
        <li>regulation year (e.g. 2022)</li>
        <li>published date (if any, e.g. Date : 11-03-2025)</li>
        <li>per-roll results: gpa1..gpa4 or referred_subjects</li>
      </ul>
      After extraction you can edit the JSON and download it.
    </div>

    <input id="pdfFile" type="file" accept="application/pdf"/>
    <div class="row">
      <button id="run">Extract</button>
      <button id="download">Download JSON</button>
      <button id="copy">Copy JSON</button>
    </div>

    <div class="small">Status: <span id="status">idle</span></div>
    <textarea id="out" placeholder="JSON output will appear here..."></textarea>
  </div>

<script>
(async ()=>{
  const fileEl = document.getElementById('pdfFile');
  const runBtn = document.getElementById('run');
  const outEl = document.getElementById('out');
  const statusEl = document.getElementById('status');
  const downloadBtn = document.getElementById('download');
  const copyBtn = document.getElementById('copy');

  // utility: find publication date patterns in text
  function findPublishedDate(text) {
    // try several date formats: 11-03-2025 , 11/03/2025 , Date : 11-03-2025, Date : 11/03/2025
    const re = /Date\s*[:\-]?\s*(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{4})/gi;
    const m = re.exec(text);
    if (m) return m[1];
    // alternative: "Date : 11-03-2025NOTICE" or "Date : 11-03-2025NOTICE" trim trailing letters
    const re2 = /Date\s*[:\-]?\s*(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{4})\b/gi;
    const mm = re2.exec(text);
    if (mm) return mm[1];
    // try other pattern like "Date : 11-03-2025NOTICE" handled above; fallback: search "Date" then digits later
    const re3 = /Date[\s\S]{0,20}?(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{4})/i;
    const mm3 = re3.exec(text);
    if (mm3) return mm3[1];
    return null;
  }

  // parse whole text into institute blocks by headings like "11044 - Institute Name"
  function splitIntoInstitutes(fullText) {
    const headerRe = /(^\s*\d{2,6}\s*-\s*[^\n\r]+)/gim;
    const headers = [];
    let match;
    while ((match = headerRe.exec(fullText)) !== null) {
      headers.push({index: match.index, header: match[0].trim()});
    }
    const blocks = [];
    if (headers.length === 0) {
      // fallback: treat entire text as single block
      blocks.push({header: null, text: fullText});
      return blocks;
    }
    for (let i=0;i<headers.length;i++){
      const start = headers[i].index;
      const end = (i+1 < headers.length) ? headers[i+1].index : fullText.length;
      const headerLine = headers[i].header;
      const body = fullText.slice(start + headerLine.length, end);
      blocks.push({header: headerLine, text: body});
    }
    return blocks;
  }

  // parse roll entries inside a block
  function parseRollEntries(blockText) {
    const results = {};

    // 1) Parenthesis style: 700014 (gpa4: 3.76, gpa3: 3.54, gpa2: 3.34, gpa1: 3.36)
    const parenRe = /(\d{5,7})\s*\(\s*([^\)]*?)\)/g;
    for (const m of blockText.matchAll(parenRe)) {
      const roll = m[1];
      const inner = m[2];
      const obj = {};
      // find all gpaX: value
      const gpaRe = /gpa\s*([1-4])\s*:\s*(ref|[\d.]+)/ig;
      let any = false;
      for (const g of inner.matchAll(gpaRe)) {
        any = true;
        const idx = 'gpa' + g[1];
        obj[idx] = (g[2].toLowerCase() === 'ref') ? 'ref' : parseFloat(g[2]);
      }
      // also sometimes ref_sub included inside same parentheses
      const ref_sub_Re = /ref_sub\s*[:\-]?\s*([^\s,}]+)/i;
      const rsub = inner.match(ref_sub_Re);
      if (rsub) {
        obj['referred_subjects'] = [ rsub[1].trim() ];
      }
      if (any) {
        results[roll] = { type: 'parsed_gpas', gpas: obj };
      }
    }

    // 2) Curly style: 700030 { 25841(T), 25931(T), ... }
    const curlyRe = /(\d{5,7})\s*\{\s*([^}]+)\}/g;
    for (const m of blockText.matchAll(curlyRe)) {
      const roll = m[1];
      const inner = m[2];
      // inner may be subject codes OR combined forms; we'll split by comma
      const parts = inner.split(',').map(s=>s.trim()).filter(Boolean);
      // if parts contain gpaX: treat accordingly
      const hasGpa = parts.some(p => /gpa\d\s*:/i.test(p));
      if (hasGpa) {
        const gpaObj = {};
        for (const p of parts) {
          const g = p.match(/gpa\s*([1-4])\s*:\s*(ref|[\d.]+)/i);
          if (g) gpaObj['gpa'+g[1]] = (g[2].toLowerCase()==='ref') ? 'ref' : parseFloat(g[2]);
          const r = p.match(/ref_sub\s*[:\-]?\s*([^\s]+)/i);
          if (r) gpaObj.referred_subjects = gpaObj.referred_subjects || [], gpaObj.referred_subjects.push(r[1]);
        }
        results[roll] = { type: 'parsed_gpas', gpas: gpaObj };
      } else {
        // treat as subjects list
        results[roll] = { type: 'referred', referred_subjects: parts };
      }
    }

    // 3) Additional: sometimes entries split over lines; try match lines starting with roll and following multiple tokens
    // e.g. lines like "700030  25841(T), 25931(T), 26811(T,P), 27041..."
    const lineRe = /^(\d{5,7})\s+([^\n\r]+)/gm;
    for (const m of blockText.matchAll(lineRe)) {
      const roll = m[1];
      const rest = m[2].trim();
      // if we already have roll parsed skip if exists
      if (results[roll]) continue;
      // if rest contains many codes
      if (/[\d]{5}\w*/.test(rest) && /[A-Za-z0-9\(\),]/.test(rest)) {
        // attempt to extract subjects
        const possible = rest.split(',').map(s=>s.trim()).filter(Boolean);
        // ensure items look like codes e.g. 25841(T) or gpa4:
        const codeLike = possible.filter(p => /^\d{5,6}/.test(p) || /gpa\d/i.test(p));
        if (codeLike.length >= 1) {
          // if contains gpa: treat as gpa line
          const hasGpa = codeLike.some(p=>/gpa\d/i.test(p));
          if (hasGpa) {
            const gpaObj = {};
            for (const p of codeLike) {
              const g = p.match(/gpa\s*([1-4])\s*:\s*(ref|[\d.]+)/i);
              if (g) gpaObj['gpa'+g[1]] = (g[2].toLowerCase()==='ref') ? 'ref' : parseFloat(g[2]);
            }
            results[roll] = { type: 'parsed_gpas', gpas: gpaObj };
          } else {
            results[roll] = { type: 'referred', referred_subjects: codeLike };
          }
        }
      }
    }

    return results;
  }

  // try find exam name & regulation in the block header / text
  function findExamAndRegulation(blockHeader, blockText) {
    let exam = null;
    let regulation = null;

    const examRe = /Examination of\s+([A-Z &\-\w]+)/i;
    const examRe2 = /Examination of\s+([A-Za-z\s]+),/i;
    const m1 = examRe.exec(blockText) || examRe2.exec(blockText);
    if (m1) exam = m1[1].trim();

    // look for "(2022 Regulation)" patterns
    const regRe = /\((\d{4})\s*Regulation\)/i;
    const m2 = regRe.exec(blockText) || regRe.exec(blockHeader || '');
    if (m2) regulation = m2[1];

    // fallback: any "Regulation" mention near top
    if (!regulation) {
      const reg2 = /Regulation\W*\)?\s*(\d{4})/i;
      const m3 = reg2.exec(blockText);
      if (m3) regulation = m3[1];
    }

    // normalize exam to uppercase if found
    if (exam) exam = exam.toUpperCase();

    return {exam, regulation};
  }

  // main parse: given full text produce JSON mapping
  function parseFullText(fullText) {
    const pubDate = findPublishedDate(fullText); // may be null
    const blocks = splitIntoInstitutes(fullText);
    const final = {};

    for (const b of blocks) {
      // header like "11044 - Himaloy Polytechnic Institute of Technology, Panchagar"
      let poly = null;
      if (b.header) {
        const hmatch = b.header.match(/^\s*(\d{2,6})\s*-\s*(.+)$/);
        if (hmatch) poly = hmatch[2].trim();
      }
      // examine block text for exam & regulation
      const {exam, regulation} = findExamAndRegulation(b.header, b.text);

      // parse roll entries in this block
      const rolls = parseRollEntries(b.text);

      for (const [roll, entry] of Object.entries(rolls)) {
        const rec = {};
        if (poly) rec.polytechnic = poly;
        if (exam) rec.exam = exam;
        if (regulation) rec.regulation = regulation;
        if (pubDate) rec.published_date = pubDate;

        // integrate parsed entry
        if (entry.type === 'parsed_gpas') {
          // place gpas into results ordered as numbers if available
          rec.results = entry.gpas;
        } else if (entry.type === 'referred') {
          rec.referred_subjects = entry.referred_subjects;
        } else {
          // fallback
          rec.note = 'parsed entry';
        }
        final[roll] = rec;
      }
    }

    return {published_date: pubDate, data: final};
  }

  async function extractFromFile(file) {
    statusEl.textContent = 'reading pdf...';
    const arr = await file.arrayBuffer();
    statusEl.textContent = 'opening pdf...';
    const pdf = await pdfjsLib.getDocument({data:arr}).promise;
    statusEl.textContent = `pdf loaded (${pdf.numPages} pages). extracting text...`;
    let fullText = '';
    for (let i=1;i<=pdf.numPages;i++){
      try {
        const page = await pdf.getPage(i);
        const tc = await page.getTextContent();
        const pageText = tc.items.map(x=>x.str).join(' ');
        fullText += '\\n' + pageText;
        if (i % 25 === 0) statusEl.textContent = `extracted ${i}/${pdf.numPages} pages...`;
      } catch (err) {
        console.error('page error', i, err);
      }
    }
    statusEl.textContent = 'parsing extracted text...';
    const parsed = parseFullText(fullText);
    statusEl.textContent = 'done';
    return parsed;
  }

  runBtn.addEventListener('click', async ()=>{
    const f = fileEl.files[0];
    if (!f) { alert('Select a PDF first'); return; }
    outEl.value = 'Working... please wait (may take a minute for large PDFs)';
    try {
      const result = await extractFromFile(f);
      // show combined: include top-level published_date and data
      const outObj = { published_date: result.published_date || null, extracted_time: (new Date()).toISOString(), data: result.data };
      outEl.value = JSON.stringify(outObj, null, 2);
    } catch (e) {
      console.error(e);
      outEl.value = 'Error: ' + (e.message || e);
      statusEl.textContent = 'error';
    }
  });

  downloadBtn.addEventListener('click', ()=>{
    const txt = outEl.value;
    if (!txt || !txt.trim()) return alert('No JSON to download');
    const blob = new Blob([txt], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'results.json';
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  });

  copyBtn.addEventListener('click', ()=>{
    const txt = outEl.value;
    if (!txt || !txt.trim()) return alert('No JSON to copy');
    navigator.clipboard.writeText(txt).then(()=> alert('Copied to clipboard'));
  });

})();
</script>
</body>
</html>
